以下都按 小-大 排序
```golang
list := []int{3, 1, 5, 7, 2, 3}
```
// 31

## 冒泡排序
比较相邻的，顺序不对则交换位置。

```golang
func Sort(){
	for i := 1; i < len(list); i++ {
       for j := i - 1; j >= 0; j-- {
           if list[j+1] < list[j] {
               list[j+1], list[j] = list[j], list[j+1]
           } // 比较简单，一直向前比较就可以。
       }
    }
}
```

## 选择排序
选取一个数做为最小的数，用后面所有的数和它比较，和冒泡比较类似。
```golang
func Sort(){
	for i := 0; i < len(list); i++ {
        min := i

        for j := i + 1; j < len(list); j++ { // 再去和后面的数比较
            if list[j] < list[min] {
                min = j // 如果比当前最小的小，把下标对调
            }
        }

        list[i], list[min] = list[min], list[i]
    }
}
```

## 快排
找一个数做基准，比基准小的放到左边，比基准大的，放到右边。
具体实现有很多方法，一边放一边排序，分类完了再对两边继续快排，直接用中间值做基准等。
```golang
func Sort(){
	length := len(list)

    right := length - 1
    left := 1 // 大小分隔点

    base := list[right] //取最后一位做基准,这个基准可以自己找,base 在最后>交换位置

    for i := 0; i < length; i++ {
        if list[i] < base { // 小于基准，和left对调
            list[i], list[left] = list[left], list[i]
            left++
        }
        // 最后 base 和 left 对调
        list[left], list[right] = list[right], list[left]
    }

    // 现在只是两边排序完了，以 left 为分界点,再迭代的排序左右。这里就不写
了，一个意思。明白其中原理是主要的。其他的各种升级版什么的，万变不离其宗。

    return list
}
	
```

## 希尔排序
## 归并排序
## 堆排序
## 计数排序
简单易懂，空间换时间，很稳定。
## 桶排序

[资料](https://www.cnblogs.com/onepixel/p/7674659.html)
