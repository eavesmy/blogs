以下都按 小-大 排序
```golang
list := []int{3, 1, 5, 7, 2, 3}
```
// 31

## 冒泡排序
比较相邻的，顺序不对则交换位置。

```golang
func Sort(){
	for i := 1; i < len(list); i++ {
       for j := i - 1; j >= 0; j-- {
           if list[j+1] < list[j] {
               list[j+1], list[j] = list[j], list[j+1]
           } // 比较简单，一直向前比较就可以。
       }
    }
}
```

## 选择排序
选取一个数做为最小的数，用后面所有的数和它比较，和冒泡比较类似。
```golang
func Sort(){
	for i := 0; i < len(list); i++ {
        min := i

        for j := i + 1; j < len(list); j++ { // 再去和后面的数比较
            if list[j] < list[min] {
                min = j // 如果比当前最小的小，把下标对调
            }
        }

        list[i], list[min] = list[min], list[i]
    }
}
```

## 快排
找一个数做基准，比基准小的放到左边，比基准大的，放到右边。
具体实现有很多方法，一边放一边排序，分类完了再对两边继续快排，直接用中间值做基准等。
```golang
func Sort(){
	length := len(list)

    right := length - 1
    left := 1 // 大小分隔点

    base := list[right] //取最后一位做基准,这个基准可以自己找,base 在最后>交换位置

    for i := 0; i < length; i++ {
        if list[i] < base { // 小于基准，和left对调
            list[i], list[left] = list[left], list[i]
            left++
        }
        // 最后 base 和 left 对调
        list[left], list[right] = list[right], list[left]
    }

    // 现在只是两边排序完了，以 left 为分界点,再迭代的排序左右。这里就不写
了，一个意思。明白其中原理是主要的。其他的各种升级版什么的，万变不离其宗。

    return list
}
	
```

## 希尔排序
## 归并排序
## 堆排序
## 桶排序
先找到最大和最小的数，然后分成几个桶，具体多少个桶取决于数组中数均匀分布的情况。比如 0 - 100 ，打乱之后排序，可以四个桶，五个桶，甚至10个桶都可以,保证每个桶的差值相同。每个桶放的是在这个桶范围内的值，桶内排序，排序完了把几个桶放出来就可以了。基本思想是这样的，但具体实现要考虑数的均匀分布情况。实际上这是一种可以自由控制时间空间的排序方式。
## 计数排序
桶排序的一种,算法如其名，空间换时间，很稳定。
## 基数排序
桶排序的一种。取数的最低位按0 - 9先排序，排序完后重新按百位排，依次按前一位排。

[资料](https://www.cnblogs.com/onepixel/p/7674659.html)
