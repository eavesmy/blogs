补补基础吧，基础太差了。
### 举个栗子
#### 十进制，二进制: 
0 0    
1 01    
2 10    
3 11    
4 100    
5 101    
6 110     
7 111    
8 1000    
9 1001    
10 1010    

### 位操作符
- ```~``` 取反 0,1 互调
- ```<<``` 左位移 末位补0
- ```>>``` 右位移 末位去一位
- ```&``` 按位与 两个数二进制中相应位数都为1时为1
- ```^``` 按位异或 两个数二进制中相应位数相同为0 不同为1
- ```|``` 按位或 两个数二进制中相应位数有一个为1就是1

#### ~ 取反(例子都是16位整型,太长不好写)
``` 
1 -> 01;
有符号: 正负颠倒,绝对值与原值差1
~1 -> -(~1) -> -(10) -> -2;
无符号: 值与上界的差
~1 -> 65535 - 1 -> 65534
```
#### << 左位移
```
4 << 1 -> 1000 -> 8
```
#### >> 右位移
```
4 >> 1 -> 10 -> 2
```
#### & 按位与
```
4 & 1 -> 0100 & 0001 -> 0000 -> 0
4 & 7 -> 0100 & 0111 -> 0100 -> 4
```
可以与1比较判断概数奇偶，0 为偶
#### ^ 按位或异
```
4 ^ 4 -> 0100 ^ 0100 -> 0000 -> 0
4 ^ 7 -> 0100 ^ 0111 -> 0011 -> 3
```
#### | 按位或
```
4 | 1 -> 0100 | 0001 -> 0101  -> 5
```

### 实用
1.以 LintCode 第一题为例,两个整数相加，可以用位运算，比如 1 + 2, 二进制表达： ```0001 + 0010 = 0011 = 3 ```, 和 ```|```操作一样，但这只是没有进位的情况。所以我们先算一下有没有进位，但查有没有进位需要从后往前推，可以用```^```判断有没有进一位，然后往前一位，直到最前面没有进位: 
```
int a = 5;
int b = 6;

while(b != 0) {
	int res = (a & b) << 1; // 是否需要进位
	a = a ^ b;  // 算出的结果
	b = res; // 有进位则继续
}
	
a 为结果。
// 第一题就挠了半天头，基础太差了。
```

### 还有一些内容，慢慢补充。
